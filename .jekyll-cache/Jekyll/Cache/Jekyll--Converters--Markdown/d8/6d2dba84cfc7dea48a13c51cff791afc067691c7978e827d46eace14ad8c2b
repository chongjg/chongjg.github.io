I"<ul>
  <li>（数字图像处理的第一个作业，结果是赶着完成的，看两篇论文并且实现搞了八个小时，最后剩两个小时写报告，深深为自己英文水平着急，草草结尾还晚交了几分钟。裂开来。</li>
</ul>

<h2 id="1histogram-equalization">1.Histogram Equalization</h2>

<ul>
  <li>
    <p>这个算法简称<strong>HE</strong>或者<strong>GHE(Global ~)</strong></p>
  </li>
  <li>
    <p>算法的思想非常简单，一个灰度图的直方图往往是不均匀的，这样对比度往往不高，我们要是能够使它的直方图变得更加均匀（比如每个灰度值的像素个数一样，它的对比度应该会比较好）。</p>
  </li>
  <li>
    <p>下面是在网上找的一张图片以及它的直方图。</p>
  </li>
</ul>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/origin.jpg" alt="" /></p>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/origin-hist.jpg" alt="" /></p>

<ul>
  <li>
    <p>从上图的直方图中可以看到，像素的分布非常不均匀，绝大多数像素都是灰度值很小的。</p>
  </li>
  <li>
    <p>通俗地讲，<strong>HE</strong>算法的思想就是让直方图中每个柱子进行不改变顺序的移动（可以合并，不能拆分），使得每个柱子的高度和它占用的灰度数相当。</p>
  </li>
  <li>
    <p>从算法实现上讲，令<script type="math/tex">cnt(i),(0\leq i\leq 255)</script>表示图像每个灰度值的像素数量，<script type="math/tex">sum(i)</script>是<script type="math/tex">cnt</script>的前缀和。那么只需要把原本的灰度值<script type="math/tex">i</script>改成新的灰度值<script type="math/tex">sum(i)*255/sum(N)</script>即可。</p>
  </li>
  <li>
    <p>算法的结果如下图所示</p>
  </li>
</ul>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/GHE.jpg" alt="" /></p>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/GHE-hist.jpg" alt="" /></p>

<ul>
  <li>
    <p>可以明显地看到直方图的柱子被移动得更均匀了，也就是柱子的高度和占的灰度数成正比了。</p>
  </li>
  <li>
    <p>然而，也可以明显看到这个算法的不足，图像明暗分界处对比度被过分增强，而明和暗各自内部的对比度并没有得到很好的增强。从直方图上可以看出来，使用HE算法时，如果图像中存在非常多的某个灰度值的像素，那么就会导致非常多的灰度值不能被使用，从而有些地方对比度过大显得不自然，而有的地方对比度又没能得到很好的提高。</p>
  </li>
  <li>
    <p>为了解决这个问题，我们需要找到一个把“柱子”拆分的方法。</p>
  </li>
</ul>

<h2 id="2neighborhood-metrics">2.Neighborhood Metrics</h2>

<ul>
  <li>
    <p>这一部分内容来自论文<a href="https://www.researchgate.net/publication/224209864_Image_Contrast_Enhancement_using_Bi-Histogram_Equalization_with_Neighborhood_Metrics?enrichId=rgreq-319bc3ef6eb4fa0f9f562c5ffd925e65-XXX&amp;enrichSource=Y292ZXJQYWdlOzIyNDIwOTg2NDtBUzo0NTY1MTE5MTU4NTk5NjhAMTQ4NTg1MjMzMDAzOQ%3D%3D&amp;el=1_x_3&amp;_esc=publicationCoverPdf">《Image Contrast Enhancement using Bi-Histogram Equalization with Neighborhood Metrics》</a></p>
  </li>
  <li>
    <p>考虑如何拆分柱子，实际上就是考虑怎么给柱子里包含的像素分配权值进行一个排序，然后分配灰度值的时候就可以不用全分配一个，而且可以按照权值挨个分配更好地利用灰度值提高对比度。</p>
  </li>
</ul>

<h3 id="21-voting-metric">2.1 Voting Metric</h3>

<ul>
  <li>
    <p>这是论文中提到第一个算法，很好理解，就是看自己的周围<script type="math/tex">8</script>个像素，比自己黑的有多少个，本着提高对比度的原则，周围比自己黑的越多，就应该在柱子里尽量分配更白的颜色。</p>
  </li>
  <li>
    <p>可以看作每个像素有了一个权值，然后每个柱子根据权值内部排序，每个柱子最多拆分成<script type="math/tex">9</script>段（拆分效果如下图），之后再对这些拆分的柱子进行HE算法即可。</p>
  </li>
</ul>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/Voting-1.png" alt="" /></p>

<ul>
  <li>按照上述思想可以得到以下结果</li>
</ul>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/HE-Voting.jpg" alt="" /></p>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/HE-Voting-hist.jpg" alt="" /></p>

<ul>
  <li>可以看到，在这幅图中，最高的柱子高度基本没变，这是因为纯黑周围不会有比它黑的，所以纯黑的柱子在这个算法下无法被拆分，还可以看到灰度值较大的区域得到了一定的平滑。不过从图片上来说没有肉眼可见变化。</li>
</ul>

<h3 id="22-contrast-difference-metric">2.2 Contrast Difference Metric</h3>

<ul>
  <li>
    <p>这个算法是在刚刚算法的基础上进行再次拆分，<script type="math/tex">2.1</script>能够把一个柱子拆成最多<script type="math/tex">9</script>个，而这个算法在刚刚<strong>拆分完的基础上</strong>再进行拆分。</p>
  </li>
  <li>
    <p>这个算法是计算周围比自己灰度值小的像素平均比自己小多少，以及比自己大的像素平均比自己大多少，分别记作<script type="math/tex">left\;average\;difference(L.a.d)</script>和<script type="math/tex">right\;average\;difference(R.a.d)</script>。</p>
  </li>
  <li>
    <p>设置一个阈值，当<script type="math/tex">% <![CDATA[
L.a.d<Threshold<R.a.d %]]></script>时权值设置为<script type="math/tex">1</script>，当<script type="math/tex">L.a.d>Threshold>R.a.d</script>时权值设置为<script type="math/tex">3</script>，否则为<script type="math/tex">2</script>。</p>
  </li>
  <li>
    <p>拆分效果如下图所示</p>
  </li>
</ul>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/Contrast-1.png" alt="" /></p>

<ul>
  <li>按照上述思想实现，可以得到以下结果</li>
</ul>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/HE-Contrast.jpg" alt="" /></p>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/HE-Contrast-hist.jpg" alt="" /></p>

<ul>
  <li>然而很不幸的是，这个改进效果甚微，几乎看不到一点差别。</li>
</ul>

<h3 id="23-neighborhood-distinction-metric">2.3 Neighborhood Distinction Metric</h3>

<ul>
  <li>
    <p>这个算法综合了上述两个算法，给出一个更加简单的实现方式。直接给每个像素分配权值为周围灰度值比它小的像素与他差的和，这样一来一个柱子最多能够被拆分为<script type="math/tex">2041</script>个柱子了。</p>
  </li>
  <li>
    <p>按照上述思想实现得到以下结果</p>
  </li>
</ul>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/HE-Neighborhood.jpg" alt="" /></p>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/HE-Neighborhood-hist.jpg" alt="" /></p>

<ul>
  <li>可以看到在直方图右部由于更细的拆分使得灰度分布更加的平滑了。只是在图片中依然没有太多体现。</li>
</ul>

<h3 id="24-总结">2.4 总结</h3>

<ul>
  <li>
    <p>从上面可以看出，仅仅靠拆分柱子是不够的，当图片中某一些像素灰度值全都一样，却不表达任何意义的时候，这些像素会占用大量的灰度值区间，</p>

  </li>
</ul>
:ET