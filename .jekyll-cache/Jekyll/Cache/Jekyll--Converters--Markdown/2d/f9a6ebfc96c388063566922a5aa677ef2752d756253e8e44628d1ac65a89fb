I"<p><strong>(持续更新中…)</strong></p>

<h2 id="telea">TELEA</h2>

<ul>
  <li>
    <p><strong><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.98.5505&amp;rep=rep1&amp;type=pdf">原论文下载</a>；<a href="https://github.com/chongjg/Image-Inpainting/blob/master/paper/An%20Image%20Inpainting%20Technique%20Based%20on%20the%20Fast%20Marching%20Method.pdf">带笔记论文下载</a></strong></p>
  </li>
  <li>
    <p>（再也不脑抽用C++实现这种算法了</p>
  </li>
  <li>
    <p>这个算法是opencv自带的图像修复算法，直接说算法的流程吧：</p>
  </li>
</ul>

<h4 id="1区域划分">1.区域划分</h4>

<ul>
  <li>把每个像素标记为<strong>KNOWN、BAND、INSIDE</strong>三种</li>
</ul>

<ol>
  <li>
    <p><strong>INSIDE</strong>：待修复的像素，表示是待修复的块的内部像素。</p>
  </li>
  <li>
    <p><strong>BAND</strong>：与待修复的像素相邻的已知像素，表示块的边界。</p>
  </li>
  <li>
    <p><strong>KNOWN</strong>：其他已知像素。</p>
  </li>
</ol>

<p><img src="https://raw.githubusercontent.com/chongjg/chongjg.github.io/master/img/Image-Inpainting/inpainting-principle.png" alt="" /></p>

<ul>
  <li>如上图(a)所示，圈内是待修复部分<strong>INSIDE</strong>，圈外是已知部分<strong>KNOWN</strong>，圈就是<strong>BAND</strong>。</li>
</ul>

<h4 id="2修复单个像素">2.修复单个像素</h4>

<ul>
  <li>
    <p>考虑修复一个与<strong>BAND</strong>相邻的未知点<script type="math/tex">p</script>，如上图(b)所示，对于附近某一个已知(<strong>BAND和KNOWN</strong>)的点<script type="math/tex">q</script>，可以通过<script type="math/tex">p=I(q)+\nabla I(q)*(p-q)</script>来预测待修复点<script type="math/tex">p</script>。</p>
  </li>
  <li>
    <p>基于这个思路，可以以<script type="math/tex">p</script>为圆心<script type="math/tex">\varepsilon</script>为半径画一个圆，如上图(a)，圆内已知像素集合记为<script type="math/tex">B_\varepsilon(p)</script>，对于任意<script type="math/tex">q\in B_\varepsilon</script>都会对<script type="math/tex">I(p)</script>有一个预测值，对每一个预测赋予合适的权值<script type="math/tex">w(p,q)</script>，最后用归一化加权预测结果作为像素修复的值，且此后将像素视为已知，继续修复下一个像素。</p>
  </li>
</ul>

<script type="math/tex; mode=display">I(p)=\frac{\underset{q\in B_\varepsilon(p)}{\sum}w(p,q)[I(q)+\nabla I(q)(p-q)]}{\underset{q\in B_\varepsilon(p)}{\sum} w(p,q)}</script>

<h4 id="3修复顺序">3.修复顺序</h4>

<ul>
  <li>
    <p>前面已经提到是一个一个像素修复，而顺序则是沿着边界往中心蔓延挨个修复。</p>
  </li>
  <li>
    <p>令<script type="math/tex">T(p)</script>表示像素<script type="math/tex">p</script>离<strong>BAND</strong>的最近距离，就可以通过<script type="math/tex">T(p)</script>从小到大修复未知的像素。（<script type="math/tex">T</script>相等的点连起来可看做等高线）</p>
  </li>
  <li>
    <p><script type="math/tex">T(p)</script>通过求解下面方程得到，实际上不是严格的距离。</p>
  </li>
</ul>

<script type="math/tex; mode=display">\vert\nabla T\vert=1,\quad with\; T=0\; in\; BAND</script>

<ul>
  <li>数值求解方法如下：</li>
</ul>

<script type="math/tex; mode=display">\max(D^{-x}T,-D^{+x}T,0)^2+\max(D^{-y}T,-D^{+y}T,0)^2=1</script>

<ul>
  <li>其中:(<script type="math/tex">D^{\pm y}</script>类似)</li>
</ul>

<script type="math/tex; mode=display">D^{-x}T(i,j)=T(i,j)-T(i-1,j)</script>

<script type="math/tex; mode=display">D^{+x}T(i,j)=T(i+1,j)-T(i,j)</script>

<ul>
  <li>令<script type="math/tex">T_0=T(i,j),T_1=T(i+\Delta i,j),T_2=T(i,j+\Delta j)</script>，则有：</li>
</ul>

<script type="math/tex; mode=display">% <![CDATA[
\begin{aligned}
(T_0-T_1)^2+(T_0-T_2)^2=&1\\
2T_0^2-2(T_1+T_2)T_0+T_1^2+T_2^2-1=&0\\
\end{aligned} %]]></script>

<ul>
  <li>解一元二次方程得：</li>
</ul>

<script type="math/tex; mode=display">T_0=\frac{(T_1+T_2)\pm\sqrt{(2-(T_1-T_2)^2)}}{2}</script>

<ul>
  <li>
    <p>通过上面的更新距离方法，再结合最短路算法SPFA可以得到所有<script type="math/tex">T</script>值（这种结合可能不太严谨，但是无伤大雅）</p>
  </li>
  <li>
    <p>此时对于<strong>KNOWN</strong>类型的点将 <script type="math/tex">T</script> 取反，这样通过 <script type="math/tex">T</script> 相减就有等高线差值的意义了。</p>
  </li>
  <li>
    <p>最后使用<script type="math/tex">3\times 3\; tent\; filter</script>处理 <script type="math/tex">T</script>，在网上查了一下这里的<script type="math/tex">tent\; filter</script>可能是指如下函数：</p>
  </li>
</ul>

<script type="math/tex; mode=display">f(x)=\left\{
\begin{aligned}
1-\vert x\vert, \vert x\vert\leq 1\\
0, \vert x\vert >1
\end{aligned}
\right.</script>

<ul>
  <li>扩展到二维我在代码里直接用的3*3高斯核。</li>
</ul>

<h4 id="4权值设置">4.权值设置</h4>

<ul>
  <li>考虑待修复点<script type="math/tex">p</script>及已知点<script type="math/tex">q\in B_\varepsilon(p)</script></li>
</ul>

<p>1.方向部分：<script type="math/tex">\nabla T</script>的方向如果和<script type="math/tex">(p-q)</script>的方向一致，则给予更大权重，设置为两者的点积。</p>

<script type="math/tex; mode=display">dir(p,q)=\frac{p-q}{\parallel p-q\parallel}\cdot \nabla T</script>

<p>2.距离部分：<script type="math/tex">p</script>和<script type="math/tex">q</script>距离越远，权重越小，设置为距离平方的倒数</p>

<script type="math/tex; mode=display">dst(p,q)=\frac{d_0^2}{\parallel p-q\parallel^2}</script>

<p>3.等高线部分：<script type="math/tex">T(p)</script>和<script type="math/tex">T(q)</script>差距越大，权重越小</p>

<script type="math/tex; mode=display">lev(p,q)=\frac{T_0}{1+\vert T(p)-T(q)\vert}</script>

<ul>
  <li></li>
</ul>

:ET