I"!<ul>
  <li>（数字图像处理的第一个作业，结果是赶着完成的，看两篇论文并且实现搞了八个小时，最后剩两个小时写报告，深深为自己英文水平着急，草草结尾还晚交了几分钟。裂开来。</li>
</ul>

<h3 id="histogram-equalization">Histogram Equalization</h3>

<ul>
  <li>
    <p>这个算法简称<strong>HE</strong>或者<strong>GHE(Global ~)</strong></p>
  </li>
  <li>
    <p>算法的思想非常简单，一个灰度图的直方图往往是不均匀的，这样对比度往往不高，我们要是能够使它的直方图变得更加均匀（比如每个灰度值的像素个数一样，它的对比度应该会比较好）。</p>
  </li>
  <li>
    <p>下面是在网上找的一张图片以及它的直方图。</p>
  </li>
</ul>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/origin.jpg" alt="" /></p>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/origin-hist.jpg" alt="" /></p>

<ul>
  <li>
    <p>从上图的直方图中可以看到，像素的分布非常不均匀，绝大多数像素都是灰度值很小的。</p>
  </li>
  <li>
    <p>通俗地讲，<strong>HE</strong>算法的思想就是让直方图中每个柱子进行不改变顺序的移动（可以合并，不能拆分），使得每个柱子的高度和它占用的灰度数相当。</p>
  </li>
  <li>
    <p>从算法实现上讲，令<script type="math/tex">cnt(i),0\leq i\leq 255</script>表示图像每个灰度值的像素数量，<script type="math/tex">sum(i)</script>是<script type="math/tex">cnt</script>的前缀和。那么只需要把原本的灰度值<script type="math/tex">i</script>改成新的灰度值<script type="math/tex">sum(i)*255/sum(N)</script>即可。</p>
  </li>
  <li>
    <p>算法的结果如下图所示</p>
  </li>
</ul>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/GHE.jpg" alt="" /></p>

<p><img src="https://github.com/chongjg/chongjg.github.io/blob/master/img/Contrast-enhancement/GHE-hist.jpg" alt="" /></p>

<ul>
  <li>
    <p>可以明显地看到直方图的柱子被移动得更均匀了，也就是柱子的高度和占的灰度数成正比了。</p>
  </li>
  <li>
    <p>然而，也可以明显看到这个算法的不足，图像明暗分界处对比度被过分增强，而明和暗各自内部的对比度并没有得到很好的增强。从直方图上可以看出来，使用HE算法时，如果图像中存在非常多的某个灰度值的像素，那么就会导致非常多的灰度值不能被使用，从而有些地方对比度过大显得不自然，而有的地方对比度又没能得到很好的提高。</p>
  </li>
  <li>
    <p>为了解决这个问题，我们需要找到一个</p>
  </li>
</ul>
:ET